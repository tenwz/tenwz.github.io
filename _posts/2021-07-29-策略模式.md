---
layout: post
title: 策略模式

---

### [函数式编程是否取代了GoF设计模式](https://www.itranslater.com/qa/details/2104072179351553024)

上边帖子里的对话很值得花时间细细思考，当你从另一个维度看设计模式的时候，你会从中得到更多。

先立个贴，等秋招过去，把设计模式的本质重新理解一遍。

用函数式的方式重写设计模式不是为了追求什么花哨的写法，而是让我能够拨开云雾去认识到编程的本质。

[函数式编程的设计模式](https://qiankunli.github.io/2018/12/15/functional_programming_patterns.html)

[解密“设计模式”](http://www.yinwang.org/blog-cn/2013/03/07/design-patterns)







----

策略设计模式

当我们解决一个问题有不同的解法的时候，又不希望客户感知到这些解法的细节，这种情况下适合使用策略模式。策略模式包括三个部分：

- 解决问题的算法（上图中的Strategy）；
- 一个或多个该类算法的具体实现（上图中的ConcreteStrategyA、ConcreteStrategyB和ConcreteStrategyC）
- 一个或多个客户使用场景（上图中的ClientContext）

### 面向对象思路

首先定义策略接口，表示排序策略：

```javascript
public interface ValidationStrategy {
    boolean execute(String s);
}
```

然后定义具体的实现类（即不同的排序算法）：

```java
public class IsAllLowerCase implements ValidationStrategy {
    @Override
    public boolean execute(String s) {
        return s.matches("[a-z]+");
    }
}

public class IsNumberic implements ValidationStrategy {
    @Override
    public boolean execute(String s) {
        return s.matches("\\d+");
    }
}
```

最后定义客户使用场景，代码如下图所示。Validator是为客户提供服务时使用的上下文环境，每个Valiator对象中都封装了具体的Strategy对象，在实际工作中，我们可以通过更换具体的Strategy对象来进行客户服务的升级，而且不需要让客户进行升级。

```java
public class Validator {

    private final ValidationStrategy strategy;

    public Validator(ValidationStrategy strategy) {
        this.strategy = strategy;
    }

    /**
     * 给客户的接口
     */
    public boolean validate(String s) {
        return strategy.execute(s);
    }
}

public class ClientTestDrive {

    public static void main(String[] args) {
        Validator numbericValidator = new Validator(new IsNumberic());
        boolean res1 = numbericValidator.validate("7780");
        System.out.println(res1);

        Validator lowerCaseValidator = new Validator(new IsAllLowerCase());
        boolean res2 = lowerCaseValidator.validate("aaaddd");
        System.out.println(res2);
    }
}
```

### 函数式编程思路

如果使用Lambda表达式考虑，你会发现ValidationStrategy就是一个函数接口（还与Predicate<String>具有同样的函数描述），那么就不需要定义上面那些实现类了，可以直接用下面的代码替换，原因是Lambda表达式内部已经对这些类进行了一定的封装。

```java
public class ClientTestDrive {

    public static void main(String[] args) {
        Validator numbericValidator = new Validator((String s) -> s.matches("\\d+"));
        boolean res1 = numbericValidator.validate("7789");
        System.out.println(res1);

        Validator lowerCaseValidator = new Validator((String s) -> s.matches("[a-z]+"));
        boolean res2 = lowerCaseValidator.validate("aaaddd");
        System.out.println(res2);
    }
}
```

---

命令设计模式



```java
public static void log(String message) {
    System.out.println("Logging: " + message);
}
 
public static void save(String message) {
    System.out.println("Saving: " + message);
}
 
public static void send(String message) {
    System.out.println("Sending: " + message);
}

List<Runnable> tasks = new ArrayList<>();
tasks.add(() -> log("Hi"));
tasks.add(() -> save("Cheers"));
tasks.add(() -> send("Bye"));
execute( tasks );
```

LogCommand、SaveCommand、SendCommand 三个函数便实现了。